#### MySQL笔记

##### 1 、为什么需要使用索引？

MySQL官方对索引的定义为：**索引（Index）是帮助 MySQL 高效获取数据的数据结构。**
白话文：**索引就像书的目录**一样可以非常快速的定位到书的页码。
如果向mysql发出一条sql语句请求，查询的字段没有创建索引的话，可能会导致全表扫描，这样的话查询效率非常低。

---

##### 2、数据结构Hash、平衡二叉树、B树、B+树区别

1）**哈希表**（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。
优点:查找可以直接根据key访问
缺点: 不能进行范围查找
index=Hash(key)
2）**平衡二叉查找树**，又称 AVL树。 它除了具备二叉查找树的基本特征之外，还具有一个非常重要的特点：它 的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值（平衡因子 ） 不超过1。 也就是说AVL树每个节点的平衡因子只可能是-1、0和1（左子树高度减去右子树高度）。
**优点:平衡二叉树算法基本与二叉树查询相同，效率比较高**
**缺点:插入操作需要旋转，支持范围查询**
3）**B树**（Btree）是一种树状数据结构，它能够存储数据、对其进行排序并允许**以O(log n)的时间复杂度运行**进行查找、顺序读取、插入和删除的数据结构。**B树，概括来说是一个节点可以拥有多于2个子节点的二叉查找树。**与自平衡二叉查找树不同，B树为系统最优化大块数据的读和写操作。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。普遍运用在数据库和文件系统。”
因为B树节点元素比平衡二叉树要多，所以B树数据结构相比平衡二叉树数据结构实现减少磁盘IO的操作。
4）**B+树**相比B树，**新增叶子节点与非叶子节点关系，叶子节点中包含了key和value，非叶子节点中只是包含了key，不包含value。**
**所有相邻的叶子节点包含非叶子节点，使用链表进行结合，有一定顺序排序，从而范围查询效率非常高。**

---

##### 3、Myisam与Innodb B+树的区别

主键索引： MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。
**MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。**
B+树相比B树，新增叶子节点与非叶子节点关系，叶子节点中包含了key和value，非叶子节点中只是包含了key，不包含value。
所有相邻的叶子节点包含非叶子节点，使用链表进行结合，有一定顺序排序，从而范围查询效率非常高
**注意：MyISAM和InnoDB对B-Tree索引不同的实现方式**
**MyISAM底层使用B+树 叶子节点的value对应存放行数的地址，在通过行数定位到数据。**
**InnoDB底层使用B+树，叶子节点的value对应存放是行的data数据，相比MyISAM效率要高一些，但是比较占硬盘内存大小。**

---

#####  4，linux服务器中查询MySQL索引文件

默认数据与索引文件位置: /var/lib/mysql
1）MyISAM引擎的文件：
.myd 即 my data，表数据文件
.myi 即my index，索引文件
.log 日志文件。
2）InnoDB引擎的文件：
采用表空间（tablespace）来管理数据，存储表数据和索引，
InnoDB数据库文件（即InnoDB文件集，ib-file set）：
ibdata1、ibdata2等：系统表空间文件，存储InnoDB系统信息和用户数据库表数据和索引，所有表共用。
.ibd文件：单表表空间文件，每个表使用一个表空间文件（file per table），存放用户数据库表数据和索引。

---

#####  5，MySQLb+树能够存放多少字节数据

局部性原理与磁盘预读
计算机科学中著名的局部性原理当一个数据被用到时， 其附近的数据也通常会马上被使用。
为了提高效率，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。
这里的-定长度叫做页，也就是操作系统操作磁盘时的基本单位。一般操作系统中.页的大小4Kb (getconf  PAGE_SIZE)所以如果在磁盘中读取1kb，实际会读取4kb。

---

#####  6，MySQL是如何定位慢查询

slow_query_log 慢查询开启状态
slow_query_log_file 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）
long_query_time 查询超过多少秒才记录
1）查询慢查询配置
show variables like 'slow_query%';
2）查询慢查询限制时间
show variables like 'long_query_time';
3）将 slow_query_log 全局变量设置为“ON”状态
set global slow_query_log='ON'; 
4）查询超过1秒就记录
set global long_query_time=1;
5）查询cat /var/lib/mysql/localhost-slow.log
service mysqld restart

---

#####  7，索引为什么会失效？注意那些事项？

1. 索引无法存储null值。
2. 如果条件中有or，in，大于，小于，即使其中有条件带索引也不会使用（会有一定的几率使用索引）。
3. like查询以%开头，无法使用索引。
4. 对于多列索引，不使用的索引的第一个字段，则不会使用索引。
5. 不可以进行函数计算和类型转换。
6. 如果mysql估计使用全表扫描要比使用索引快,则不使用索引。

---

##### 8，联合索引为什么需要遵循左前缀原则？

如果在一张表中，存在联合索引的话，在根据条件查询的时候必须要加上第一个索引条件。
因为索引底层采用B+树叶子节点顺序排列，必须通过左前缀索引才能定位到具体的节点范围。

---

#####  9，分表分库为什么能够提高数据库查询效率？

分表分库为什么提高查询的效率？因为会将一张表的数据拆分成多个n张表进行存放，让后在使用第三方中间件（MyCat或者Sharding-JDBC）并行同时查询，让后在交给第三方中间进行组合返回给客户端。

---

##### 10，jdbc 和mybites有还什么区别

MyBatis是对JDBC的封装。

相对于JDBC，MyBatis有以下优点：

1. 连接池优化获取和释放。
2. L统一管理，对数据库进行存取操作 。
3. 成动态SQL语句，
4. 对结果集进行映射

---

##### 11、MySQL四层结构

1. 连接层。提供客户端连接。
2. 服务层。提供客户使用的接口，提供SQL优化器。
3. 引擎层。提供存储数据的方式（InnoDB，MyISAM）。
4. 存储层。存储数据。

---

##### 12、MySQL索引的类型

1. 普通索引。这是最基本的索引，它没有任何限制，比如上文中为title字段创建的索引就是一个普通索引，MyIASM中默认的BTREE类型的索引，也是我们大多数情况下用到的索引。

2. 唯一索引。与普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值（注意和主键不同）。如果是组合索引，则列值的组合必须唯一，创建方法和普通索引类似。

3. 全文索引。

4. 单列索引、多列索引。多个单列索引与单个多列索引的查询效果不同，因为执行查询时，MySQL只能使用一个索引，会从多个索引中选择一个限制最为严格的索引。

5. 组合索引（最左前缀）。平时用的SQL查询语句一般都有比较多的限制条件，所以为了进一步榨取MySQL的效率，就要考虑建立组合索引。

   ---

##### 13、MySQL Explain获取执行计划

通过 explain 我们可以知道以下信息：表的读取顺序，数据读取操作的类型，哪些索引可以使用，哪些索引实际使用了，表之间的引用，每张表有多少行被优化器查询等信息。

```xml
id | select_type | table | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+-------+---------------+---------+---------+-------+------+--
|  1 | SIMPLE      | film  | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
```

id  代表执行的顺序 ，id 相同 从上往下执行 ， id不同 则id值较大的先执行。

mysql查看性能工具explain中type有很多种，主要的有：

**system > const > eq_ref > ref > range > index > ALL**

***其中system ，const 只是理想情况，实际效果能达到ref，rang。***

| **链接类型**    | **说明**                                                     |
| --------------- | ------------------------------------------------------------ |
| system          | 表只有**一行**，`MyISAM`引擎。                               |
| const           | 常量连接，表最多只有一行匹配，通用用于**主键**或者**唯一索引**比较时 |
| eq_ref          | 每次与之前的表合并行都只在该表读取一行，这是除了system，const之外最好的一种，特点是使用=，而且索引的所有部分都参与**join**且索引是**主键**或**非空唯一键**的索引 |
| ref             | 如果每次只匹配少数行，那就是比较好的一种，使用=或<=>，可以是左覆盖索引或**非主键**或**非唯一**键 |
| fulltext        | 全文搜索                                                     |
| ref_or_null     | 与`ref`类似，但包括`NULL`                                    |
| index_merge     | 表示出现了索引合并优化(包括交集，并集以及交集之间的并集)，但不包括跨表和全文索引。这个比较复杂，目前的理解是合并单表的范围索引扫描（如果成本估算比普通的range要更优的话） |
| unique_subquery | 在in子查询中，就是value in (select…)把形如`select unique_key_column`的子查询替换。PS：所以不一定in子句中使用子查询就是低效的！ |
| index_subquery  | 同上，但把形如”select non_unique_key_column“的子查询替换     |
| range           | 常数值的范围                                                 |
| index           | 索引树扫描。a.当查询是索引覆盖的，即所有数据均可从索引树获取的时候（Extra中有Using Index）；b.以索引顺序从索引中查找数据行的全表扫描（无 Using Index）；c.如果Extra中Using Index与Using Where同时出现的话，则是利用索引查找键值的意思；d.如单独出现，则是用读索引来代替读行，但不用于查找 |
| all             | 全表扫描(full table scan)                                    |

---









